import requests
from bs4 import BeautifulSoup
import click
import csv
from colorama import Fore, Back, Style
from typing import Tuple, List, Dict


def get_nuts() -> Tuple[str, str]:
    """Downloads nuts codes

    Gets all scrapable nuts codes (the green ones).

    Yields:
        Tuple[str, str]: (<nuts_code>, <corresponding_name>)
    """
    # TODO: handle the unhappy path
    nuts_url = "https://volby.cz/opendata/ps2017nss/PS_nuts.htm"
    r = requests.get(nuts_url)
    r.encoding = "windows-1250"
    soup = BeautifulSoup(r.text, "lxml")
    for row in soup.find_all("tr"):
        cols = row.find_all("td", attrs={"class": "xl678667"})
        if cols:
            code = cols[0].text
            name = cols[1].text
            print(code, name)
            yield code, name


def get_obce(code: str) -> Tuple[str, str]:
    """Downloads obce names

    Given a single nuts code returns all 'obce' in 'okres' corresponding to the code.

    Args:
        code (str): Nuts code indentifying an 'okres'

    Yields:
        Tuple[str, str]: (<nuts_code>, <obec_name>)
    """
    # TODO: handle the unhappy path
    r = requests.get(f"https://volby.cz/pls/ps2017nss/vysledky_okres?nuts={code}")
    soup = BeautifulSoup(r.text, "lxml")
    for obec in soup.find_all("obec"):
        yield code, obec["naz_obec"]


def get_party_names(filename: str) -> None:
    """Downloads party names

    Party codes need to be translated to actual names. This function creates the mapping and saves it to csv file.

    Args:
        filename (str): Name of the csv file to save the mapping to.
    """
    # TODO: handle the unhappy path
    url = "https://volby.cz/pls/ps2017nss/vysledky"
    r = requests.get(url)
    soup = BeautifulSoup(r.text, "lxml")
    with open(filename, "w", newline="") as csvfile:
        fieldnames = ["code", "strana_name"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        kraj = soup.find("kraj")
        for strana in kraj.find_all("strana"):
            writer.writerow(
                {"code": strana["kstrana"], "strana_name": strana["naz_str"]}
            )


def generate_obce_csv(filename: str) -> None:
    """Generates obce csv

    For each nuts code generated by get_nuts() the 'obce' generated by get_obce() are saved to to a csv file.

    Args:
        filename (str): Name of the target csv file.
    """
    with open(filename, "w", newline="") as csvfile:
        fieldnames = ["code", "okres_name", "obec_name"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for nuts_code, name in get_nuts():
            for code, obec_name in get_obce(nuts_code):
                writer.writerow(
                    {"code": code, "okres_name": name, "obec_name": obec_name}
                )


def read_obce_csv(filename: str) -> List[Dict]:
    """Read obce csv

    Reads the 'obce' names from a csv file.

    Args:
        filename (str): Description

    Returns:
        List[Dict]: Description
    """
    with open(filename, newline="") as csvfile:
        reader = csv.DictReader(csvfile)
        list_out = [row for row in reader]
    return list_out


def read_party_names(filename: str) -> List[Dict]:
    """Read parties csv

    Reads the party names from a csv file.

    Args:
        filename (str): Description

    Returns:
        List[Dict]: Description
    """
    with open(filename, newline="") as csvfile:
        reader = csv.DictReader(csvfile)
        list_out = [row for row in reader]
    return list_out


def get_okres_results(okres_code: str, obec_name: str) -> List[Tuple[str, str]]:
    """Get results for one obec

    Gets the results for one specific 'okres', and finds the specified 'obec' in those results and parses them into a list.

    Args:
        okres_code (str): Okres code/Nuts code of the 'okres' the function will fetch the results for.
        obec_name (str): Name of 'obec' user queried for.

    Returns:
        List[Tuple[str, str]]: (<party_code>, <percentage>)
    """
    # TODO: handle the unhappy path
    okres_url = f"https://volby.cz/pls/ps2017nss/vysledky_okres?nuts={okres_code}"
    r = requests.get(okres_url)
    soup = BeautifulSoup(r.text, "lxml")
    obec = soup.find("obec", attrs={"naz_obec": obec_name})
    return [(x["kstrana"], x["proc_hlasu"]) for x in obec.find_all("hlasy_strana")]


def transform_results(
    results: List[Tuple[str, str]], parties: List[Dict], sort_results: bool = True
) -> List[Dict]:
    """Transform results before graphing

    Performs data transformation, most importantly it converts the percantages to proper floats, maps names to codes of parties and sorts the results if needed.

    Args:
        results (List[Tuple[str, str]]): List of the untransformed results
        parties (List[Dict]): Code to name mapping for parties
        sort_results (bool, optional): Enables/disables sorting of the transformed results.

    Returns:
        List[Dict]: Transformed list of dicts containing keys name, percentage, code
    """
    # TODO: use pandas or smth
    transformed = []
    for r in results:
        name = [x["strana_name"] for x in parties if x["code"] == r[0]][0]
        percentage = float(r[1])

        transformed.append({"name": name, "percentage": percentage, "code": int(r[0])})
    if sort_results:
        newlist = sorted(transformed, key=lambda k: k["percentage"], reverse=True)
        return newlist
    return transformed


def graph_results(results: List[Dict]) -> None:
    """Graphs results

    Graphs the results using colored printing to terminal

    Args:
        results (List[Dict]): List of dicts containing keys name, percentage, code
    """
    fat_tick = "â–‡"
    colors = [
        Fore.GREEN,
        Fore.YELLOW,
        Fore.WHITE,
        Fore.BLUE,
        Fore.RED,
        Fore.CYAN,
        Fore.MAGENTA,
    ]
    for r in results:
        bar = fat_tick + fat_tick * int(r["percentage"])
        if r["percentage"] == 0.0:
            bar = ""
        color = colors[r["code"] % len(colors)]
        print(f"{color} {bar}{Style.RESET_ALL} {r['name']} {str(r['percentage'])}%")


@click.command()
@click.option(
    "--obec",
    prompt=True,
    help="Name of the obec you are intrested in, if ambiguous interactive choice will be shown.",
)
@click.option(
    "--refresh/--no-refresh",
    default=False,
    help="Some static data are stored in the names.csv and parties.csv files, use --refresh to recreate those files.",
)
@click.option(
    "--sort-results/--no-sort-results",
    default=True,
    help="Use --no-sort-results if you do not want the results sorted by percentage of votes recieved.",
)
def volby_cli(obec: str, refresh: bool, sort_results: bool) -> None:
    """
    Tool to get live colorful voting results for a specified obec. Data are downloaded from https://volby.cz each time you run this.
    """
    if refresh:

        generate_obce_csv("names.csv")
        get_party_names("parties.csv")
    try:
        obce_list = read_obce_csv("names.csv")
        parties = read_party_names("parties.csv")
    except FileNotFoundError:
        click.echo("Obce csv file not found use --refresh first")
        exit(1)
    click.echo(f"Searching {obec}!")
    matches = [x for x in obce_list if x["obec_name"] == obec]

    if len(matches) == 0:
        click.echo(f"Found no obec matching {obec}!")
        exit(1)
    elif len(matches) == 1:
        click.echo("One obec found!")
        results = get_okres_results(matches[0]["code"], matches[0]["obec_name"])
    elif len(matches) > 1:
        click.echo(f"Found multiple obec matching the name {obec}!")
        for o in matches:
            print(f"{o['code']}: {o['okres_name']} - {o['obec_name']}")
        code = click.prompt(
            "Select one code", type=click.Choice([o["code"] for o in matches])
        )
        matches = [x for x in matches if x["code"] == code]
        results = get_okres_results(matches[0]["code"], matches[0]["obec_name"])

    trans = transform_results(results, parties, sort_results)
    graph_results(trans)


if __name__ == "__main__":
    volby_cli()
